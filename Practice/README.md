# 详细实现

## 1-codec

- 实现**编/解码**(消息的序列化/反序列化)
- 实现一个**简易服务端**(server)来接受消息
- 在`main()`中使用`net.Dial()`拨号模拟一次rpc请求(客户端)
- 编码时使用`bufio.Writer`创建**写缓冲**，提高发送请求性能
- 在解码时使用`sync.Mutex`互斥锁来确保其他go协程往同一个缓冲区写入
- 处理请求时使用`sync.WaitGroup`同步器来确保**一次连接**中，服务端能处理完**所有请求**后，再断开连接

这里引用下网友`panjianning`的UML图:
![](img/codec_1.png)

## 2-client

- 实现一个支持异步和高并发的客户端

客户端和服务端一次连接 的报文格式如下:

>>| Option{MagicNumber: xxx, CodecType: xxx} | Header{ServiceMethod ...} | Body interface{} |
>
>> <------      固定 JSON 编码      ------>  | <-------   编码方式由 CodeType 决定   ------->|
>
>>|协议交换|请求头|请求体|请求头|请求体|
- 使用`sync.Mutex`互斥锁,来确保客户端**多个请求发送**时的可用性
- 基于`net.Dia()`实现客户端的`Dial()`功能，连接过程为

    - 解析opt格式
  
        - 没有入参opt则按照默认RPC编码格式
    - 使用`net.Dia()`连接服务端，使用返回的`conn`对象和`opt`来新建客户端实例并以Json格式编码发送给服务端
    - 服务端接收Json格式解码验证`opt`格式
- 实现异步接口`Go`，客户端发送RPC请求后，**异步**接收成功发送请求的确认信息，在网络情况不太好的情况下，提高了一些性能
- 基于上述的异步接口`Go`，封装了同步接口`Call`，同步下使用的是普通信道
- 
    ```go
        done = make(chan *Call, 10)
    ```
    官方对于回调的`chan`的处理为新建了容量为10的缓冲信道,个人认为容量为一的普通信道即可？

- 客户端使用`协程`并发 发送多个RPC请求

## 3-service
> 一次RPC调用是客户端请求服务端的一个服务方法，传入`方法名`和`方法需要的参数`,客户端`解析请求`返回`结果值`
> 之前仅仅是完成了协议确认、服务端接收到RPC请求,打印出请求头信息,服务端还缺少了解析服务请求方法的功能

- 通过反射，客户端获取某个结构体的所有方法，并且能够通过方法，获取到该方法所有的参数类型与返回值

- 关于一次RPC调用过程，可以简单阐述一下：

  - 客户端封装好 {`服务名.请求方法`, 入参, 出参} 为一个Call结构体，放入请求队列中
  - 请求队列中，根据序列号依次取出 Call 请求，封装好信息到请求头发送，
  - 服务端接收到请求头后，解析里面的方法，根据服务名查找本地是否有对应服务
  
    - 本地服务端维护一张字典表，记载注册的服务
  - 解析请求体的时候，会根据入参的接口类型，根据反射创建入参实例
  - 随后根据解析好的方法类型、入参通过反射调用方法
  - 最后返回请求头和处理好的结果
